{"name":"M","tagline":"Lightweight single page bone for mobile web App.轻量级web端单页面骨架","body":"M — Lightweight single page bone for mobile web App.轻量级web端单页面骨架\r\n=\r\n\r\n\r\n[![NPM Version][npm-image]][npm-url]\r\n[![NPM Downloads][downloads-image]][downloads-url]\r\n\r\n\r\n[DEMO](http://demo.aijc.net/js/M/examples/)\r\n\r\n[require.js DEMO](http://demo.aijc.net/js/M/examples/requirejs/)\r\n\r\n### 优势：\r\n\r\n* 使用简单、方便、轻量，基于 [history](https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Manipulating_the_browser_history)、[window.onpopstate](https://developer.mozilla.org/en-US/docs/WindowEventHandlers.onpopstate)。\r\n\r\n* 无依赖，可与其他框架（库）搭配自由使用，例如：`jquery`, `zepto`, `iscroll`等。\r\n\r\n* 任意选择字符串式模板引擎，当然最简单的就是自己拼接字符串了；同时支持异步（远程获取模板，或者去请求数据在前端构建模板）；可配置是否缓存结果模板。\r\n\r\n* 考虑后端渲染首屏的情况，只需要按结构输出响应的片段即可，利于`SEO`，且可以实现前后端模板公用。\r\n\r\n* 自动缓存部分画面，可配置缓存数量，默认3个。\r\n\r\n* 每个路由都有对应的`callback`和`onDestroy`配置方法，分别用于显示了对应画面后的回调以及当该画面销毁时回调。\r\n\r\n* 利用`CSS animation`控制动画变换效果，也可设置关闭动画效果。\r\n\r\n* “保留”浏览器原生`hash`功能，根据`hash`，可自由跳转到对应`id`元素位置。\r\n\r\n* 可配置`enablePushState`决定是否使用`pushstate`功能，默认启用；不启用的话，仅仅影响的是不产生历史，但是路由依旧好使的，也就是还是基于`url`的。\r\n\r\n### 一些注意点：\r\n\r\n* 不管画面是否已缓存在页面中，只要切换回显示了，那么就会调用`callback`，而`callback`中大多数情况需要处理监听事件、操作`DOM`，这时候可根据`this.cached`来区分；当没有缓存在页面上时为`false`，或者缓存在页面上了，但是模板更新了，这时候也为`false`。\r\n\r\n* `getTemplate`配置方法，如果带有参数，那么该参数就是得到模板字符串后的回调函数，一定要回调的；如果没有参数，直接返回模板字符串即可。这样做，主要是为了考虑异步获取（render）模板的场景。\r\n\r\n* `M.history`的默认的 base path 是页面中`base`元素的`href`的值，如果没有，则默认是`/`；也可以在`M.history.start()`时传入。\r\n\r\n* 对于[history](https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Manipulating_the_browser_history)、[window.onpopstate](https://developer.mozilla.org/en-US/docs/WindowEventHandlers.onpopstate)不支持或者支持不够好的浏览器来说，能够正常匹配对应`route`，也就是说能够正常调用`route`配置项中的`getTemplate`以及`callback`（`onDestroy`除外），其他功能都没有，点击链接直接刷新页面。这样就可以在不改变代码的情况下，适配了不支持的浏览器。当然这种情况也可以通过取得`M.history.support`来判断，如果不支持的话，可以在调用`M.history.start`时设置参数`enablePushState`为`false`也可以，但不建议，因为没有历史记录了。\r\n\r\n### 使用方法：\r\n\r\n```js\r\nM.router.init([\r\n\t{\r\n\t\tpath: '/',\r\n\t\tcacheTemplate: false, // 针对于当前的route，是否缓存模板\r\n\t\tgetTemplate: function() {\r\n\t\t\treturn '/index';\r\n\t\t},\r\n\t\tcallback: function() {\r\n\t\t\tif (this.cached) return;\r\n\t\t\t// 处理操作...\r\n\t\t},\r\n\t\tonDestroy: function() {\r\n\t\t\t// 例如，处理一些解绑操作，销毁和DOM关联\r\n\t\t}\r\n\t},\r\n\t{\r\n\t\tpath: '/c/:paramName',\r\n\t\tcacheTemplate: false, // 针对于当前的route，是否缓存模板\r\n\t\tgetTemplate: function(cb) {\r\n\t\t\t// 这里模拟异步得到模板内容\r\n\t\t\tvar that = this;\r\n\t\t\t// that.params 参数信息\r\n\t\t\t// that.query query信息\r\n\t\t\tsetTimeout(function() {\r\n\t\t\t\tcb('/c/' + that.params.paramName);\r\n\t\t\t}, 200);\r\n\t\t},\r\n\t\tcallback: function(paramName) {\r\n\t\t\tif (this.cached) return;\r\n\t\t\t// 处理操作...\r\n\t\t},\r\n\t\tonDestroy: function() {\r\n\t\t\t// 例如，处理一些解绑操作，销毁和DOM关联\r\n\t\t}\r\n\t}\r\n], {\r\n\t/*是否缓存模板*/\r\n\tcacheTemplate: true,\r\n\r\n\t/*views容器选择器 如果为空，或者没有符合元素，那么views的容器元素就为body了*/\r\n\tviewsSelector: '',\r\n\r\n\t/*view的class*/\r\n\tviewClass: 'page-view',\r\n\r\n\t/*是否有动画*/\r\n\tanimation: true,\r\n\t/*有动画的话，动画的类型*/\r\n\taniClass: 'slide',\r\n\r\n\t/*蒙层class 主要是显示loading时的蒙层*/\r\n\tmaskClass: 'mask',\r\n\t/*显示loading*/\r\n\tshowLoading: true,\r\n\r\n\t/*缓存view数*/\r\n\tcacheViewNum: 3\r\n});\r\n\r\n// 也可以通过这种形式添加\r\nM.router.get('/ddd/{dddID:int}', function(dddID) {\r\n\t// 这是 callback 回调\r\n}, {\r\n\tcacheTemplate: true,\r\n\tgetTemplate: function() {\r\n\t\treturn '/ddd/' + this.params.dddID;\r\n\t},\r\n\tonDestroy: function() {\r\n\t\t// destroy\r\n\t}\r\n});\r\n\r\n/* 监听route change */\r\n/* routeChangeStart 是刚开始的时候被触发，此时还没有调用getTemplate得到模板内容 */\r\nM.router.on('routeChangeStart', function(currentRouteState) {\r\n\t\r\n});\r\n/*已经完成动画切换（如有动画效果的话）显示出来之后触发*/\r\nM.router.on('routeChangeEnd', function(currentRouteState) {\r\n\t\r\n});\r\n\r\n// 开始 监听history\r\nM.history.start({\r\n\t// base: '/', // base path\r\n\t// enablePushState: true // 启用pushstate\r\n});\r\n\r\n```\r\n\r\n### 关于配置\r\n\r\n`aniClass`和`cacgeTemplate`配置，依次取的是链接元素上的`data-xxx`->单个route规则中对一个的配置项->整体route配置规则中的配置。\r\n\r\n### examples中示例\r\n\r\n* `index.html`: 基本使用，都是默认配置，主要是关于`getTemplate`的2中方式以及在链接元素加入`data-rel=back`（反方向动画）配置。\r\n\r\n* `index2.html`: 关闭动画示例。\r\n\r\n* `index3.html`: 不缓存模板示例。\r\n\r\n* `index4.html`: 全局更改动画class示例。\r\n\r\n* `index5.html`: 局部更改动画class的两种方式示例。\r\n\r\n* `index6.html`: 局部更改缓存模板的两种方式示例。\r\n\r\n* `index7.html`: `M.history`禁用掉pushstate示例。\r\n\r\n* `requirejs/`: 使用 [require.js](http://requirejs.org/) 示例\r\n\r\n### 后端渲染\r\n\r\n只需要在响应时加入对应的页面结构即可：\r\n\r\n```html\r\n<div class=\"page-view\">后端渲染内容</div>\r\n```\r\n\r\n这是因为默认第一次初始化时，会查找页面上带有`viewClass`的元素，如果找到了，且`innerHTML`不为空，那么就不会再去调用`getTemplate`来得到模板内容了。\r\n\r\n### 代码风格\r\n\r\n没有用空格，而是用的`tab`。\r\n\r\n### 协议\r\n\r\n[MIT](https://github.com/dolymood/M/blob/master/LICENSE)\r\n\r\n[npm-image]: https://img.shields.io/npm/v/mobile-router.js.svg?style=flat\r\n[npm-url]: https://npmjs.org/package/mobile-router.js\r\n[downloads-image]: https://img.shields.io/npm/dm/mobile-router.js.svg?style=flat\r\n[downloads-url]: https://npmjs.org/package/mobile-router.js\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}